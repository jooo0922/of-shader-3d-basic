#include "ofApp.h"

//--------------------------------------------------------------
void ofApp::setup(){
    ofDisableArbTex(); // 스크린 픽셀 좌표를 사용하는 텍스쳐 관련 오픈프레임웍스 레거시 지원 설정 비활성화. (uv좌표계랑 다르니까!)
    ofEnableDepthTest(); // 깊이테스트를 활성화하여 z좌표값을 깊이버퍼에 저장해서 z값을 기반으로 앞뒤를 구분하여 렌더링할 수 있도록 함.
    
    /**
     2D 메쉬와 다르게 3D 메쉬는
     버텍스를 일일이 추가할 수 없을 정도로 복잡하기 때문에,
     일반적으로 외부 모델링 파일을 로드하여 사용하는 경우가 많음.
     
     오픈프레임웍스는 기본적으로 .ply 포맷의 모델링 파일을 지원하며,
     ofMesh 객체의 load() 함수를 이용해서 간단하게 모델을 불러올 수 있음.
     
     셰이더, 텍스쳐 파일과 마찬가지로, bin/data 디렉토리에
     모델링 파일을 저장해뒀다면, 파일명만 인자로 넣어줘도
     알아서 로드해 옴.
     */
    torusMesh.load("torus.ply");
    uvShader.load("passthrough.vert", "uv_vis.frag"); // torus 메쉬에 적용할 셰이더 파일 로드
}

//--------------------------------------------------------------
void ofApp::update(){

}

//--------------------------------------------------------------
void ofApp::draw(){
    using namespace glm; // 이제부터 현재 블록 내에서 glm 라이브러리에서 꺼내 쓸 함수 및 객체들은 'glm::' 을 생략해서 사용해도 됨.
    
    // 카메라 뷰 행렬 및 투영행렬 계산에 필요한 값들을 구해놓음.
    cam.pos = vec3(0, 0, 1); // 카메라 위치는 z축으로 1만큼 안쪽으로 들어가게 함.
    cam.fov = radians(100.0f); // 시야각은 원근투영 프러스텀(절두체)의 왼쪽면과 오른쪽면 사이의 각도로, 일반 PC 게임에서는 90도 전후의 값을 사용함. -> degree 각도를 라디안 각도로 변환하는 glm 내장함수 radians() 를 사용함.
    float aspect = 1024.0f / 768.0f; // main.cpp 에서 정의한 윈도우 실행창 사이즈를 기준으로 종횡비(aspect)값을 계산함.

    // 모델행렬, 뷰행렬, 투영행렬 계산
    /**
     모델행렬 계산에는 회전행렬 및 크기행렬만 적용함.
     
     1. 회전행렬 함수의 회전축 인자값
     glm 회전행렬 함수는 두 개의 인자를 받음.
     첫 번째는 회전 각도,
     두 번째는 vec3 형태의 회전축
     
     아래와 같이 회전축을 (1, 1, 1) 로 전달해줬다면,
     x, y, z 축 각각을 1.0f 라디안 각도만큼 회전시키겠다는 뜻임.
     
     실제로 렌더링된 torus 를 보면 각 축 방향으로 한번씩 회전해줘야 ㅈ
     렌더링된 모양으로 나오게 됨.
     
     2. 행렬 곱셈 순서
     원래는 크기 * 회전 * 이동 순으로 곱하는 게 맞음.
     근데 이거는 '행 우선 행렬' 일 때의 순서임.
     
     그러나, glm 라이러리는 '열 우선 행렬'을 사용하므로,
     원하는 행렬 곱셈 순서의 반대로 곱해줘야 함.
     
     즉, 이동 * 회전 * 크기 순으로 곱해야 하며,
     모델행렬에서 이동변환은 안할거기 때문에
     회전 * 크기 순으로 곱해준 것.
     */
    mat4 model = rotate(1.0f, vec3(1, 1, 1)) * scale(vec3(0.5, 0.5, 0.5));
    
    // 카메라 상태값 구조체 변수 cam에 저장된 pos값만큼 카메라를 이동변환 시키는 뷰행렬 계산.
    // -> 뷰행렬은 카메라 움직임에 따라 나머지 대상들을 정확히 반대방향으로 움직이는 변환행렬이므로, inverse() glm 내장함수로 역행렬로 만들어줌. (오픈프레임웍스 내장함수 아님!)
    mat4 view = inverse(translate(cam.pos));
    
    // glm 내장함수 perspective(float fov, float aspect, float near, float far) 를 사용해 원근투영행렬을 만듦.
    mat4 proj = perspective(cam.fov, aspect, 0.01f, 10.0f);
    
    // 버텍스 셰이더의 mvp 행렬 유니폼변수로 보낼 변환행렬을 미리 합쳐둠.
    // 항상 모델행렬 -> 뷰행렬 -> 투영행렬 순으로 곱해야 하는 것 기억해둘 것!
    // 이때, glm 라이브러리로 만든 행렬들은 전부 열 우선 행렬이기 때문에, 원하는 행렬곱셈 순서와 정 반대로 곱해야 되서 투영행렬 * 뷰행렬 * 모델행렬 순으로 곱한 것 뿐임!
    mat4 mvp = proj * view * model;
    
    // uvShader 를 바인딩하여 사용 시작
    uvShader.begin();
    
    // uvShader.setUniformMatrix4f("mvp", mat4()); // 일단 테스트삼아 단위행렬을 mvp 행렬로 보내주도록 함. (그냥 glm::mat4() 호출하면 단위행렬이 리턴된다고 했지?)
    uvShader.setUniformMatrix4f("mvp", mvp); // 위에서 합쳐준 mvp 행렬을 mvp 유니폼 변수로 보내줌.
    torusMesh.draw(); // torus 메쉬 드로우콜 호춣여 그려줌
    
    uvShader.end();
    // uvShader 사용 중단
}

//--------------------------------------------------------------
void ofApp::keyPressed(int key){

}

//--------------------------------------------------------------
void ofApp::keyReleased(int key){

}

//--------------------------------------------------------------
void ofApp::mouseMoved(int x, int y ){

}

//--------------------------------------------------------------
void ofApp::mouseDragged(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mousePressed(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mouseReleased(int x, int y, int button){

}

//--------------------------------------------------------------
void ofApp::mouseEntered(int x, int y){

}

//--------------------------------------------------------------
void ofApp::mouseExited(int x, int y){

}

//--------------------------------------------------------------
void ofApp::windowResized(int w, int h){

}

//--------------------------------------------------------------
void ofApp::gotMessage(ofMessage msg){

}

//--------------------------------------------------------------
void ofApp::dragEvent(ofDragInfo dragInfo){ 

}
